<!-- Highcharts -->
<script src="/HistoryView/static/highcharts/highstock.js"></script>
<script src="/HistoryView/static/highcharts/exporting.js"></script>
<script src="/HistoryView/static/highcharts/export-data.js"></script>
<script src="/HistoryView/static/highcharts/accessibility.js"></script>

<div id="widget_history_{{ widget_config.id }}" style="position: relative; height: 100%; display: flex; flex-direction: column; overflow: hidden;">
  <div id="chart_{{ widget_config.id }}" style="flex: 1; min-height: 0; width: 100%; overflow: hidden;"></div>
</div>

<script>
(function() {
  'use strict';
  
  const widgetId = '{{ widget_config.id }}';
  const chartContainerId = 'chart_' + widgetId;
  const widgetConfig = {{ widget_config | tojson }};
  const propertiesData = {{ properties_data | tojson }};
  const propertiesLabels = {{ properties_labels | tojson }};
  
  // Get Bootstrap colors
  function getBootstrapColors() {
    const body = document.querySelector('[data-tag="body"]') || document.body;
    const currentTheme = body.getAttribute('data-bs-theme');
    const isDark = currentTheme === 'dark';
    
    const getCSSVariable = (varName) => {
      const value = getComputedStyle(body).getPropertyValue(varName).trim();
      return value || null;
    };
    
    const primary = getCSSVariable('--bs-primary') || (isDark ? '#0d6efd' : '#0d6efd');
    const textColor = getCSSVariable('--bs-body-color') || (isDark ? '#fff' : '#212529');
    const backgroundColor = getCSSVariable('--bs-body-bg') || (isDark ? '#212529' : '#fff');
    const borderColor = getCSSVariable('--bs-border-color') || (isDark ? '#495057' : '#dee2e6');
    const gridLineColor = borderColor;
    
    return {
      primary: primary,
      textColor: textColor,
      backgroundColor: backgroundColor,
      borderColor: borderColor,
      gridLineColor: gridLineColor
    };
  }
  
  // Apply Bootstrap theme to Highcharts
  function applyBootstrapTheme() {
    const colors = getBootstrapColors();
    
    Highcharts.setOptions({
      time: {
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
      },
      colors: [
        colors.primary,
        '#198754',
        '#0dcaf0',
        '#ffc107',
        '#dc3545',
        '#6c757d',
        '#fd7e14',
        '#20c997',
        '#6f42c1',
        '#d63384'
      ],
      chart: {
        backgroundColor: colors.backgroundColor,
        borderColor: colors.borderColor,
        style: {
          color: colors.textColor,
          fontFamily: 'var(--bs-font-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif)'
        }
      },
      title: {
        style: {
          color: colors.textColor
        }
      },
      xAxis: {
        gridLineColor: colors.gridLineColor,
        lineColor: colors.borderColor,
        tickColor: colors.borderColor,
        labels: {
          style: {
            color: colors.textColor
          }
        }
      },
      yAxis: {
        gridLineColor: colors.gridLineColor,
        lineColor: colors.borderColor,
        tickColor: colors.borderColor,
        labels: {
          style: {
            color: colors.textColor
          }
        }
      },
      legend: {
        backgroundColor: colors.backgroundColor,
        itemStyle: {
          color: colors.textColor
        },
        itemHoverStyle: {
          color: colors.primary
        }
      },
      tooltip: {
        backgroundColor: colors.backgroundColor,
        borderColor: colors.borderColor,
        style: {
          color: colors.textColor
        }
      }
    });
  }
  
  // Calculate chart height based on widget container
  let lastCalculatedHeight = null;
  function calculateChartHeight() {
    const widgetContainer = document.getElementById('widget_history_' + widgetId);
    const chartContainer = document.getElementById(chartContainerId);
    
    if (!widgetContainer || !chartContainer) {
      return 300; // default fallback
    }
    
    // Check if we're on a fullscreen page (widget_page.html)
    // More reliable detection: check for container-fluid parent and card-body with flex-grow
    const containerFluid = widgetContainer.closest('.container-fluid');
    const cardBody = widgetContainer.closest('.card-body.flex-grow-1');
    const isFullscreenPage = containerFluid !== null && cardBody !== null;
    
    if (isFullscreenPage) {
      // For fullscreen page, use viewport height minus header and margins
      const viewportHeight = window.innerHeight;
      const headerHeight = 100; // Approximate header + padding
      const margins = 40; // Top and bottom margins
      const calculatedHeight = Math.max(400, viewportHeight - headerHeight - margins);
      
      // Prevent infinite loop: only update if height changed significantly
      if (lastCalculatedHeight === null || Math.abs(calculatedHeight - lastCalculatedHeight) > 10) {
        lastCalculatedHeight = calculatedHeight;
        return calculatedHeight;
      }
      return lastCalculatedHeight;
    }
    
    // For widget mode (in dashboard), use container-based calculation
    // Find the card container that wraps the widget
    let widgetCard = widgetContainer.closest('.card');
    if (!widgetCard) {
      widgetCard = widgetContainer.closest('.widget-card');
    }
    if (!widgetCard) {
      widgetCard = widgetContainer.parentElement;
    }
    
    if (widgetCard) {
      // Prefer actual widget container height to avoid unused strips
      const widgetHeight = widgetContainer.clientHeight || widgetContainer.getBoundingClientRect().height;
      if (widgetHeight > 0) {
        const calculatedHeight = Math.max(200, widgetHeight - 4);
        if (lastCalculatedHeight === null || Math.abs(calculatedHeight - lastCalculatedHeight) > 10) {
          lastCalculatedHeight = calculatedHeight;
          return calculatedHeight;
        }
        return lastCalculatedHeight;
      }

      // Fallback to card height when widget container size is not available
      const cardRect = widgetCard.getBoundingClientRect();
      const cardPadding = 16; // p-2 class = 0.5rem * 2 = 16px total vertical padding
      const calculatedHeight = Math.max(200, cardRect.height - cardPadding);
      
      // Prevent infinite loop: only update if height changed significantly
      if (lastCalculatedHeight === null || Math.abs(calculatedHeight - lastCalculatedHeight) > 10) {
        lastCalculatedHeight = calculatedHeight;
        return calculatedHeight;
      }
      return lastCalculatedHeight;
    }
    
    // Fallback: use widget container's available height directly
    const widgetRect = widgetContainer.getBoundingClientRect();
    const containerHeight = widgetRect.height;
    const calculatedHeight = Math.max(200, containerHeight - 20);
    
    // Prevent infinite loop
    if (lastCalculatedHeight === null || Math.abs(calculatedHeight - lastCalculatedHeight) > 10) {
      lastCalculatedHeight = calculatedHeight;
      return calculatedHeight;
    }
    return lastCalculatedHeight;
  }
  
  // Create chart
  function createChart() {
    applyBootstrapTheme();
    
    const colors = getBootstrapColors();
    const chartType = widgetConfig.chart_type || 'line';
    const renderChartType = chartType === 'step' ? 'line' : chartType;
    const seriesStep = chartType === 'step' ? 'left' : undefined;
    
    const getSeriesType = (type) => (type === 'step' ? 'line' : type);
    const getSeriesStep = (type) => (type === 'step' ? 'left' : undefined);
    
    const propertiesMetaMap = {};
    if (Array.isArray(widgetConfig.properties)) {
      widgetConfig.properties.forEach((entry) => {
        if (entry && typeof entry === 'object') {
          const name = entry.name || (entry.object && entry.property ? entry.object + '.' + entry.property : null);
          if (name) {
            propertiesMetaMap[name] = entry;
          }
        }
      });
    }
    
    // Check if pie chart
    if (chartType === 'pie') {
      // Prepare pie chart data
      const pieData = [];
      for (const [propName, data] of Object.entries(propertiesData)) {
        if (data && data.length > 0) {
          // Get label for this property (description)
          const propLabel = propertiesLabels[propName] || propName;
          // Data format: [['Value1', count1], ['Value2', count2], ...]
          pieData.push(...data.map(item => ({
            name: item[0] + ' (' + propLabel + ')',
            y: item[1]
          })));
        }
      }
      
      if (pieData.length === 0) {
        document.getElementById(chartContainerId).innerHTML = 
          '<div style="text-align: center; padding: 20px; color: ' + colors.textColor + ';">{{ _("No data available") }}</div>';
        return;
      }
      
      const chartHeight = calculateChartHeight();
      
      // Ensure chart container has proper constraints
      const chartContainer = document.getElementById(chartContainerId);
      if (chartContainer) {
        chartContainer.style.maxHeight = chartHeight + 'px';
        chartContainer.style.height = chartHeight + 'px';
        chartContainer.style.overflow = 'hidden';
      }
      
      // Check if we're in widget mode (not fullscreen page)
      const widgetContainer = document.getElementById('widget_history_' + widgetId);
      const isWidgetMode = widgetContainer && widgetContainer.closest('.container-fluid') === null;
      
      const chartOptions = {
        chart: {
          renderTo: chartContainerId,
          type: 'pie',
          height: chartHeight,
          spacingTop: isWidgetMode ? 4 : 10,
          spacingRight: 10,
          spacingBottom: isWidgetMode ? 0 : 10,
          spacingLeft: 10
        },
        title: {
          text: '{{ widget_config.name }}',
          // In widget mode, make title smaller and more compact
          style: {
            fontSize: isWidgetMode ? '12px' : '16px'
          },
          margin: isWidgetMode ? 3 : 15
        },
        plotOptions: {
          pie: {
            allowPointSelect: true,
            cursor: 'pointer',
            dataLabels: {
              enabled: widgetConfig.show_legend !== false,
              format: '<b>{point.name}</b>: {point.percentage:.1f} %'
            },
            showInLegend: widgetConfig.show_legend !== false
          }
        },
        series: [{
          name: 'Values',
          data: pieData
        }],
        credits: {
          enabled: false
        },
        exporting: {
          enabled: {% if widget_config.show_context_menu %}true{% else %}false{% endif %}
        }
      };
      
      const chart = new Highcharts.Chart(chartOptions);
      
      window['chart_' + widgetId] = chart;
      return chart;
    }
    
    // For other chart types (line, column, spline, area, step)
    const series = [];
    
    // Prepare series data
    for (const [propName, data] of Object.entries(propertiesData)) {
      if (data && data.length > 0) {
        // Get label for this property (description)
        const propLabel = propertiesLabels[propName] || propName;
        const meta = propertiesMetaMap[propName] || {};
        const resolvedType = meta.chart_type || chartType;
        const resolvedRenderType = getSeriesType(resolvedType);
        const resolvedStep = getSeriesStep(resolvedType) || (resolvedType === chartType ? seriesStep : undefined);
        const resolvedColor = meta.color ? String(meta.color).trim() : '';
        
        series.push({
          name: propLabel,
          data: data,
          type: resolvedRenderType,
          step: resolvedStep,
          color: resolvedColor || undefined
        });
      }
    }
    
    if (series.length === 0) {
      // No data available
      document.getElementById(chartContainerId).innerHTML = 
        '<div style="text-align: center; padding: 20px; color: ' + colors.textColor + ';">{{ _("No data available") }}</div>';
      return;
    }
    
    const chartHeight = calculateChartHeight();
    
    // Ensure chart container has proper constraints
    const chartContainer = document.getElementById(chartContainerId);
    if (chartContainer) {
      chartContainer.style.maxHeight = chartHeight + 'px';
        chartContainer.style.height = chartHeight + 'px';
      chartContainer.style.overflow = 'hidden';
    }
    
    // Check if we're in widget mode (not fullscreen page)
    const widgetContainer = document.getElementById('widget_history_' + widgetId);
    const isWidgetMode = widgetContainer && widgetContainer.closest('.container-fluid') === null;
    
    const chartOptions = {
      chart: {
        renderTo: chartContainerId,
        type: renderChartType,
        height: chartHeight,
        zooming: {
          type: 'x'
        },
        resetZoomButton: true,
        spacingTop: isWidgetMode ? 4 : 10,
        spacingRight: 10,
        spacingBottom: isWidgetMode ? 0 : 10,
        spacingLeft: 10
      },
      title: {
        text: '{{ widget_config.name }}',
        // In widget mode, make title smaller and more compact
        style: {
          fontSize: isWidgetMode ? '12px' : '16px'
        },
        margin: isWidgetMode ? 3 : 15
      },
      xAxis: {
        type: 'datetime',
        crosshair: true
      },
      yAxis: {
        title: {
          text: null
        }
      },
      legend: {
        enabled: widgetConfig.show_legend !== false,
        // In widget mode, make legend more compact
        layout: isWidgetMode ? 'horizontal' : 'horizontal',
        align: 'center',
        verticalAlign: isWidgetMode ? 'bottom' : 'bottom',
        itemMarginBottom: isWidgetMode ? 2 : 5
      },
      navigator: {
        enabled: widgetConfig.show_navigator !== false && !isWidgetMode,
        height: isWidgetMode ? 0 : 40,
        series: {
          color: colors.primary,
          lineColor: colors.primary
        }
      },
      rangeSelector: {
        enabled: widgetConfig.show_range_selector !== false && !isWidgetMode,
        buttons: [
          { type: 'hour', count: 1, text: '1h' },
          { type: 'hour', count: 6, text: '6h' },
          { type: 'day', count: 1, text: '1D' },
          { type: 'week', count: 1, text: '1W' },
          { type: 'month', count: 1, text: '1M' },
          { type: 'all', text: 'All' }
        ],
        selected: widgetConfig.show_range_selector !== false ? 5 : undefined,
        inputEnabled: false
      },
      series: series,
      credits: {
        enabled: false
      },
      exporting: {
        enabled: {% if widget_config.show_context_menu %}true{% else %}false{% endif %}
      }
    };
    
    // Create chart
    const chart = new Highcharts.StockChart(chartOptions);
    
    // Store chart reference for resize handling
    window['chart_' + widgetId] = chart;
    
    return chart;
  }
  
  // Handle resize with debounce to prevent infinite loops
  let resizeTimeout = null;
  function handleResize() {
    // Clear existing timeout
    if (resizeTimeout) {
      clearTimeout(resizeTimeout);
    }
    
    // Debounce resize handling
    resizeTimeout = setTimeout(() => {
      const chart = window['chart_' + widgetId];
      const chartContainer = document.getElementById(chartContainerId);
      if (chart && chartContainer) {
        const newHeight = calculateChartHeight();
        const currentHeight = chart.chartHeight;
        
        // Update container maxHeight
        chartContainer.style.maxHeight = newHeight + 'px';
        chartContainer.style.height = newHeight + 'px';
        
        // Only update if height changed significantly (more than 5px)
        if (currentHeight === undefined || Math.abs(newHeight - currentHeight) > 5) {
          chart.setSize(null, newHeight, false);
        }
      }
    }, 150);
  }
  
  // Initialize chart when DOM is ready
  function initChart() {
    // Wait a bit for layout to settle
    setTimeout(() => {
      createChart();
      
      // Watch for resize events - observe window resize instead of container
      // This prevents infinite loops from ResizeObserver
      window.addEventListener('resize', handleResize);
      
      // Also observe container, but with throttling
      if (window.ResizeObserver) {
        const widgetContainer = document.getElementById('widget_history_' + widgetId);
        if (widgetContainer) {
          const resizeObserver = new ResizeObserver((entries) => {
            // Only trigger if the resize is from window, not from chart itself
            for (const entry of entries) {
              const { width, height } = entry.contentRect;
              // Check if resize is significant (more than 10px change)
              if (lastCalculatedHeight === null || Math.abs(height - lastCalculatedHeight) > 10) {
                handleResize();
              }
            }
          });
          resizeObserver.observe(widgetContainer);
        }
      }
    }, 100);
  }
  
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initChart);
  } else {
    initChart();
  }
  
  // Handle theme change
  function handleThemeChange() {
    const existingChart = window['chart_' + widgetId];
    if (existingChart) {
      // Apply new theme globally
      applyBootstrapTheme();
      
      const colors = getBootstrapColors();
      const chartType = widgetConfig.chart_type || 'line';
      
      // For pie chart, update with different options
      if (chartType === 'pie') {
        existingChart.update({
          chart: {
            backgroundColor: colors.backgroundColor,
            style: {
              color: colors.textColor
            }
          },
          plotOptions: {
            pie: {
              dataLabels: {
                style: {
                  color: colors.textColor
                }
              }
            }
          },
          legend: {
            backgroundColor: colors.backgroundColor,
            itemStyle: {
              color: colors.textColor
            },
            itemHoverStyle: {
              color: colors.primary
            }
          },
          tooltip: {
            backgroundColor: colors.backgroundColor,
            borderColor: colors.borderColor,
            style: {
              color: colors.textColor
            }
          }
        }, true);
        return;
      }
      
      // Update chart with all theme-related options for other chart types
      existingChart.update({
        chart: {
          backgroundColor: colors.backgroundColor,
          style: {
            color: colors.textColor,
            fontFamily: 'var(--bs-font-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif)'
          }
        },
        title: {
          style: {
            color: colors.textColor
          }
        },
        xAxis: {
          gridLineColor: colors.gridLineColor,
          lineColor: colors.borderColor,
          tickColor: colors.borderColor,
          labels: {
            style: {
              color: colors.textColor
            }
          }
        },
        yAxis: {
          gridLineColor: colors.gridLineColor,
          lineColor: colors.borderColor,
          tickColor: colors.borderColor,
          labels: {
            style: {
              color: colors.textColor
            }
          }
        },
        legend: {
          backgroundColor: colors.backgroundColor,
          itemStyle: {
            color: colors.textColor
          },
          itemHoverStyle: {
            color: colors.primary
          }
        },
        tooltip: {
          backgroundColor: colors.backgroundColor,
          borderColor: colors.borderColor,
          style: {
            color: colors.textColor
          }
        },
        rangeSelector: {
          buttonTheme: {
            fill: colors.backgroundColor,
            stroke: colors.borderColor,
            style: {
              color: colors.textColor
            },
            states: {
              hover: {
                fill: colors.borderColor,
                stroke: colors.borderColor,
                style: {
                  color: colors.textColor
                }
              },
              select: {
                fill: colors.primary,
                stroke: colors.borderColor,
                style: {
                  color: '#fff'
                }
              }
            }
          },
          inputBoxBorderColor: colors.borderColor,
          inputStyle: {
            backgroundColor: colors.backgroundColor,
            color: colors.textColor
          },
          labelStyle: {
            color: colors.textColor
          }
        },
        navigator: {
          handles: {
            backgroundColor: colors.backgroundColor,
            borderColor: colors.borderColor
          },
          outlineColor: colors.borderColor,
          series: {
            color: colors.primary,
            lineColor: colors.primary
          },
          xAxis: {
            gridLineColor: colors.gridLineColor
          }
        }
      }, true); // true = redraw
    }
  }
  
  // Watch for theme changes
  const body = document.querySelector('[data-tag="body"]') || document.body;
  let lastTheme = body.getAttribute('data-bs-theme');
  
  const themeObserver = new MutationObserver(() => {
    const currentTheme = body.getAttribute('data-bs-theme');
    if (currentTheme !== lastTheme) {
      lastTheme = currentTheme;
      // Small delay to ensure CSS variables are updated
      setTimeout(() => {
        handleThemeChange();
      }, 100);
    }
  });
  
  themeObserver.observe(body, {
    attributes: true,
    attributeFilter: ['data-bs-theme']
  });
  
  // Also listen for theme toggle clicks (fallback)
  const themeToggle = document.querySelector('.theme-toggle, [data-bs-theme-toggle], button[data-bs-theme]');
  if (themeToggle) {
    themeToggle.addEventListener('click', () => {
      setTimeout(() => {
        handleThemeChange();
      }, 200);
    });
  }
})();
</script>

